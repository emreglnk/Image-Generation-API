import os
import io
import replicate
from fastapi import FastAPI, Header, HTTPException, Security, Request
from fastapi.middleware.cors import CORSMiddleware
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from PIL import Image, ImageColor
from fastapi.responses import StreamingResponse

app = FastAPI()

# --- SECURITY AND CONFIGURATION ---
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Environment Variables
REPLICATE_API_TOKEN = os.getenv("REPLICATE_API_TOKEN")
API_SECRET_KEY = os.getenv("API_SECRET_KEY")
ALLOWED_ORIGINS = os.getenv("ALLOWED_ORIGINS", "*").split(",")

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Token Verification
async def verify_token(x_access_token: str = Header(...)):
    if x_access_token != API_SECRET_KEY:
        raise HTTPException(status_code=403, detail="Access Denied: Invalid Key")
    return x_access_token

# --- PROMPT LOGIC ---

def create_simple_prompt(product_name, bgstyle):
    """Generate a simple prompt based on product name and background style"""
    base_prompt = f"Professional food photography of {product_name}"
    
    if bgstyle == "transparent":
        return f"{base_prompt}, isolated on transparent background, studio lighting, top-down view"
    elif bgstyle == "image":
        return f"{base_prompt}, natural restaurant setting, lifestyle photography, depth of field"
    elif bgstyle == "solid":
        return f"{base_prompt}, neutral gray studio backdrop, soft shadows, minimalist, clean"
    elif bgstyle.startswith("#"):
        # Hex color - convert to color name description and include hex for precision
        color_name = hex_to_color_name(bgstyle)
        return f"{base_prompt}, isolated on {color_name} background ({bgstyle}), studio lighting, clean, accurate color matching"
    else:
        return f"{base_prompt}, white background, studio lighting"

def hex_to_color_name(hex_color):
    """Convert hex color to descriptive name for prompt"""
    try:
        rgb = ImageColor.getrgb(hex_color)
        r, g, b = rgb
        
        # Simple color mapping
        if r > 200 and g > 200 and b > 200:
            return "white"
        elif r < 50 and g < 50 and b < 50:
            return "black"
        elif r > 150 and g < 100 and b < 100:
            return "red"
        elif r < 100 and g > 150 and b < 100:
            return "green"
        elif r < 100 and g < 100 and b > 150:
            return "blue"
        elif r > 150 and g > 150 and b < 100:
            return "yellow"
        elif r > 150 and g < 100 and b > 150:
            return "purple"
        elif r < 100 and g > 150 and b > 150:
            return "cyan"
        elif r > 150 and g > 100 and b < 100:
            return "orange"
        elif 100 < r < 200 and 100 < g < 200 and 100 < b < 200:
            return "gray"
        else:
            return "neutral"
    except:
        return "white"

@app.get("/api/generate", dependencies=[Security(verify_token)])
@limiter.limit("10/minute")
async def generate_menu_item(request: Request, w: str, bgstyle: str = "transparent"):
    
    if not w:
        raise HTTPException(status_code=400, detail="Product name missing")

    try:
        # 1. Create Simple Prompt
        prompt = create_simple_prompt(w, bgstyle)
        print(f"Prompt: {prompt} | Style: {bgstyle}")

        # 2. Nano-Banana Configuration
        # Nano-banana only supports "jpg" and "png"
        nano_input = {
            "prompt": prompt,
            "aspect_ratio": "1:1",
            "output_format": "png" if bgstyle == "transparent" else "jpg"
        }
        
        # 3. Generate Image with Nano-Banana
        output = replicate.run("google/nano-banana", input=nano_input)
        
        # 4. Read Image Data
        image_data = output.read()
        input_img = Image.open(io.BytesIO(image_data)).convert("RGBA")

        out = io.BytesIO()

        # 5. Process Image for Custom Hex Colors (if needed)
        if bgstyle.startswith("#") and bgstyle != "transparent":
            # Apply custom hex color background
            try:
                bg_color_rgb = ImageColor.getrgb(bgstyle)
                final_bg = Image.new("RGBA", input_img.size, bg_color_rgb + (255,))
                composite = Image.alpha_composite(final_bg, input_img)
                composite.convert("RGB").save(out, format="WEBP", quality=95)
            except ValueError:
                # Fallback to original image
                print(f"Invalid color code: {bgstyle}, using generated image as-is.")
                input_img.convert("RGB").save(out, format="WEBP", quality=95)
        else:
            # Use image as generated by nano-banana
            if bgstyle == "transparent":
                input_img.save(out, format="PNG")
            else:
                input_img.convert("RGB").save(out, format="WEBP", quality=95)

        # 6. Response
        out.seek(0)
        media_type = "image/png" if bgstyle == "transparent" else "image/webp"
        return StreamingResponse(out, media_type=media_type)

    except Exception as e:
        print(f"Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))
